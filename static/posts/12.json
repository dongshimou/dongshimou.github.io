{"title":"竟然有这种操作","author":"skadi","date":"2017-07-22 08:30","tags":["c++","函数指针","这种操作"],"content":"<p>写这个起因是因为在写qt的时候,有个界面上同一个位置有不同\n<code>Widget</code>,但是槽都是一样的,而且都是同一个类派生出来的</p>\n<p>然后我写了一个模板去<code>InitRightLayout</code>,在接受信号的我\n用一个lambda去包裹了一下这个槽,然后被说多次一举.</p>\n<p>举个例子:</p>\n<pre><code>//widget a 有一个 onTimeOut\n//widget b 继承于a,重写了 onTimeOut\n//在模板中\ntemplate&lt;class T&gt;\nvoid InitRightLayout(T* cap){\n    //...\n    connect(m_timer,&amp;QTimer::timeout,\n    this,[=](){\n        onTimeOut();\n    });\n    //...\n}\n</code></pre>\n<p>告诉我可以直接写成 <code>connect(m_timer,&amp;QTimer::timeout,this,&amp;a::onTimeOut)</code>. </p>\n<p>QWQ,还有这种操作,不怕全调用了a的<code>onTimeOut</code>么?然后我测试了一下</p>\n<pre><code>class AAA :public QWidget {\npublic:\n    AAA(QWidget*parent = nullptr) :QWidget(parent) { init(); };\n    virtual void onTest() { qDebug() &lt;&lt; \"AAA\"; }\n    void init() {\n        auto t = new QTimer{ this };\n        connect(t, &amp;QTimer::timeout, this, &amp;AAA::onTest);\n        t-&gt;start(1000);\n    }\n};\nclass BBB :public AAA {\npublic:\n    BBB(QWidget*parent = nullptr) :AAA(parent) { };\n    virtual void onTest()override { qDebug() &lt;&lt; \"BBB\"; }\n};\n</code></pre>\n<p>真的是输出<code>BBB</code>,<code>AAA::onTest</code>只是一个虚地址啊,学习了.最后写了一个demo来学习一下.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct AAA {\n    virtual void func() { cout &lt;&lt; \"AAA\" &lt;&lt; endl; }\n};\n\nstruct BBB : AAA {\n    virtual void func() override { cout &lt;&lt; \"BBB\" &lt;&lt; endl; }\n};\n\nvoid run(AAA *s, void (AAA::*const f)(void)) {\n    (s-&gt;*f)();\n    return;\n}\nint main() {\n    AAA a;\n    BBB b;\n    constexpr const auto f = &amp;AAA::func;\n    run(&amp;a, f);\n    run(&amp;b, f);\n    cin.get();\n    return 0;\n}\n</code></pre>","iso8601Date":"2017-07-22T08:30:00+08:00","basename":"12","prev":"11","next":"13"}