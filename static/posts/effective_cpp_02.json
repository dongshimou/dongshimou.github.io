{"title":"effective c++ 读书笔记 02","author":"skadi","date":"2017-10-17 23:30","tags":["读书笔记","cpp"],"content":"<p>今天又读了一个章节多.<code>资源管理</code>和<code>设计与声明</code></p>\n<p>资源管理感觉基本就是要求申请资源和释放资源要成对出现.\n举了一些方法来实现这种做法.\n我现在使用<code>impl</code>的方式来封装资源.</p>\n<p>例如:</p>\n<pre><code>class widget{\nprivate:\n    struct Private;\n    Private* impl;\n    // .hpp 声明Private指针\n}\n\nstruct widget::Private{\n    string name;\n    //其他的成员\n    // .cpp 实现\n}\n</code></pre>\n<p>基本做到了这些.</p>\n<p>而设计与声明,有<a href=\"#item23\">item23</a>没做到.为啥要使用c的风格,\n即使用gobal函数去替换掉member函数.</p>\n<p>还有<a href=\"#item24\">item24</a>没有做到,因为没考虑到过这个.</p>\n<p><a href=\"#item25\">item25</a>是使用impl模式,但是并没有去特别实现一个swap.\n好像我暂时还没遇到过需要swap的情况...<del>大概是我忘记了.</del></p>\n<p>参数传<code>const&amp;</code>做到了,不返回引用,成员变量为private等等这些都做到了.</p>\n<h3 id=\"\">资源管理</h3>\n<p><a href=\"#item13\">item13:以对象管理资源</a></p>\n<p><a href=\"#item14\">item14:在资源管理类中小心copying行为</a></p>\n<p><a href=\"#item15\">item15:在资源管理类中提供对原始资源的访问</a></p>\n<p><a href=\"#item16\">item16:成对使用new和delete是要采取相同的形式</a></p>\n<p><a href=\"#item17\">item17:以独立语句讲newed对象置入智能指针</a></p>\n<h3 id=\"-1\">设计与声明</h3>\n<p><a href=\"#item18\">item18:让接口容易被正确使用,不易被误用</a></p>\n<p><a href=\"#item19\">item19:设计class犹如设计type</a></p>\n<p><a href=\"#item20\">item20:宁以pass-by-reference-to-const替换pass-by-value</a></p>\n<p><a href=\"#item21\">item21:必须返回对象时,别妄想返回其reference</a></p>\n<p><a href=\"#item22\">item22:讲成员变量声明为private</a></p>\n<p><a href=\"#item23\">item23:宁以non-member,non-friend替换member函数</a></p>\n<p><a href=\"#item24\">item24:若所有参数皆需类型转换,请为此采用non-member函数</a></p>\n<p><a href=\"#item25\">item25:考虑写出一个不抛异常的swap函数</a></p>\n<h1 id=\"item13\">item13</h1>\n<p>使用RAII对象,保证资源的正确获取和释放.c++11的常见是 <code>unique_ptr</code> 和<code>shared_ptr</code>.</p>\n<p>我还经常这么用:</p>\n<pre><code>struct widget::Private{\n    window win;\n    //...\n};\n</code></pre>\n<p>然后使用 <code>&amp;impl-&gt;win</code> 来传这个window参数.</p>\n<h1 id=\"item14\">item14</h1>\n<p>资源管理类要小心复制行为,一般都建议<code>delete</code>复制行为,只复制其资源的引用计数.</p>\n<p>不过所管理的资源的复制行为可以决定RAII对象的复制行为</p>\n<h1 id=\"item15\">item15</h1>\n<p>资源管理类要提供对原始资源的访问,因为要去兼容一些API或者需要进行一些特别的\n行为</p>\n<p>是否实现一个隐式的转换函数去访问原始资源,这个需要看情况去决定.</p>\n<p>实现这个转换,使得使用起来更加方便,但是可能会出现一些安全问题.</p>\n<h1 id=\"item16\">item16</h1>\n<p><code>new</code>和<code>delete</code>需要使用同样的方式, 如果是<code>new[]</code> 那么需要 <code>delete[]</code></p>\n<p><code>new[]</code>然后<code>delete</code>,虽然原始类型不会有问题,但是自定义的class就可能会出问题.</p>\n<p>还有就是尽量不要使用类似的<code>typedef</code>:</p>\n<pre><code>typedef std::string AddressLines[4];\n//...\nauto pal=new AddressLines;\n\ndelete[] pal;\n//而不是delete pal\n</code></pre>\n<h1 id=\"item17\">item17</h1>\n<p>使用单独的语句来讲对象置入智能指针.书中举了一个编译器优化的问题.</p>\n<pre><code>processWidget(std::tr1::shared_ptr&lt;Widget&gt;(new Widget),priority());\n</code></pre>\n<p>书上说可能由于编译器优化,执行顺序变成了</p>\n<ul>\n<li>new Widget</li>\n<li>priority()</li>\n<li>tr1::shared_ptr</li>\n</ul>\n<p>然而c++11的<code>shared_ptr</code>只能使用<code>std::make_shared&lt;Widget&gt;()</code>返回一个<code>shared_ptr</code>,所以...这条就不存在问题了.</p>\n<h1 id=\"item18\">item18</h1>\n<p>让接口更容易使用,不易误用.也就是说要求更好的设计class和function.</p>\n<p>\"促进正确使用\",也就是尽量保证设计出来的接口与使用者习惯保持一致,\n或者与内置类型保持一致的行为.</p>\n<p>\"防止误用\",也就是说用一些方法去阻止使用者的不良好的调用.</p>\n<p>书上举了<code>month</code>的例子,使用<code>month::Jan()</code>防止调用api的时候的<code>int</code>转换问题</p>\n<p>如<code>date(1993,2,10);</code>不同的地区习惯不一样.设计为\n<code>date(year(1993),month::Feb(),day(10));</code></p>\n<p>明确了年月日,这样如果填入<code>date(1993,10,2)</code>会有编译器的提示.</p>\n<h1 id=\"item19\">item19</h1>\n<p>设计<code>class</code>犹如设计<code>type</code>.这个可讨论的范围就很大了.\n而且这个需要工程经验的积累.并不是一下就能熟练的.</p>\n<ul>\n<li>新类型的对象应该如何被创建和销毁</li>\n<li>对象的初始化和复制应该有什么差别</li>\n<li>新类型的对象如果按值传递意味着什么</li>\n<li>什么是新类型的合法值</li>\n<li>新类型是否需要配合某个继承图系</li>\n<li>新类型需要什么养的转换</li>\n<li>什么样的操作符和函数对此类型而言是合理的</li>\n<li>什么样的函数应该被<code>delete</code></li>\n<li>谁会使用这个类型的成员</li>\n<li>什么是新类型的\"未声明接口\"</li>\n<li>新类型是否需要转换成一个模版</li>\n</ul>\n<h1 id=\"item20\">item20</h1>\n<p>以const引用的方式代替传值.这个非常好理解.\n因为传值的话,会生成原始参数的拷贝,并使用这个拷贝.</p>\n<p>这会多产生一次这个类拷贝构造和析构.如果是派生类的话,会更多.\n而且,这个类的成员如果是庞大的类的话,那么可以想象是要花费多少\n额外的消耗.</p>\n<p>还可以防止传递一个基类指针的时候,把派生类的属性切割了.</p>\n<p>所以我们选择传引用,但是为了保证不被修改,所以需要<code>const</code>修饰.</p>\n<p>不过内置类型,如<code>int``double</code>之类的就不必了.还有stl的迭代器和<code>functor</code></p>\n<h1 id=\"item21\">item21</h1>\n<p>不要返回临时对象(local stack)的引用或者指针,因为这个对象在离开这个作用域的时候已经被销毁了.</p>\n<p>这是一个未定义行为,因为你的对象已经不见了.也不要返回引用或者指针指向一个(local static)对象而这个对象可能同时有多个.</p>\n<h1 id=\"item22\">item22</h1>\n<p>成员变量为<code>private</code>,使用请使用<code>function</code>去获取,保持接口的一致性,因为不知道什么时候这个类就改变了,如果直接调用成员变量可能导致各种后续问题.</p>\n<h1 id=\"item23\">item23</h1>\n<p>然而这一条,我并没有做到,感觉 <code>non-member</code>function更加的偏向C.</p>\n<p>比较一下这两个函数:</p>\n<pre><code>window* createWindow(window* w,int width,int height);\n//non-member\nwindow* window::createWindow(int width,int height);\n//member\n</code></pre>\n<p>我在<code>Webkit</code>浏览器内核经常看到类是的<code>non-member</code>函数,\n貌似是为了导出c的api</p>\n<h1 id=\"item24\">item24</h1>\n<p>如果函数所有的参数都需要类型转换,使用<code>non-member</code>的函数,\n这个非常好理解,就是为了防止出错.\n用面向对象的方式使用C++,需要注意到这一点.\n书上举了一个例子:</p>\n<pre><code>class Rational{\npublic:\n    const Rational operator*(const Rational&amp; rhs)const;\n    //...\n};\n\nauto r1=Rational(1)*Rational(2);\n//正确\nauto r2=Rational(1)*2;\n//正确\nauto r3=2*Rational(1);\n//错误\n</code></pre>\n<p>r2的时候做了一个隐式转换,然而r3却并不能.</p>\n<p>这个时候可以声明一个friend的重载:</p>\n<pre><code>friend const node operator*(const node&amp;lhs,const node&amp;rhs);\n</code></pre>\n<p>然而书上建议不使用friend,而在class外声明一个<code>non-member</code>的重载:</p>\n<pre><code>const node operator*(const node&amp;lhs,const node&amp;rhs);\n</code></pre>\n<h1 id=\"item25\">item25</h1>\n<p>考虑写一个不抛出异常的<code>swap</code>.stl的swap会进行三次复制.如果采用<code>impl</code>的\n方法则只需要交换其<code>impl</code>指针的地址就行了.</p>\n<p>写了一个<code>member</code>的swap的时候,也提供一个<code>non-member</code>的swap来调用前者,</p>","iso8601Date":"2017-10-17T23:30:00+08:00","basename":"effective_cpp_02","prev":"19","next":"effective_cpp_01"}