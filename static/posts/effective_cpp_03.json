{"title":"effective c++ 读书笔记 03","author":"skadi","date":"2017-10-26 12:11","tags":["cpp"],"content":"<p>继续看书,烦心事一串,只能写代码的时候能静心.</p>\n<p>耳机一戴,另外一个世界.</p>\n<h3 id=\"\">实现</h3>\n<p><a href=\"#item26\">item26:尽可能咽喉变量定义式的出现时间</a></p>\n<p><a href=\"#item27\">item27:尽量少做转型动作</a></p>\n<p><a href=\"#item28\">item28:避免返回handles指向对象内部成员</a></p>\n<p><a href=\"#item29\">item29:为\"异常安全\"而努力是值得的</a></p>\n<p><a href=\"#item30\">item30:透彻了解inlining的里里外外</a></p>\n<p><a href=\"#item31\">item31:将文件间的编译依存关系降至最低</a></p>\n<h3 id=\"-1\">继承与面向对象设计</h3>\n<p><a href=\"#item32\">item32:确定你的public继承塑模出is-a关系</a></p>\n<p><a href=\"#item33\">item33:避免遮掩继承而来的名称</a></p>\n<p><a href=\"#item34\">item34:区分接口继承和实现继承</a></p>\n<p><a href=\"#item35\">item35:考虑virtual函数以外的其他选择</a></p>\n<p><a href=\"#item36\">item36:绝不重新定义继承而来的non-virtual函数</a></p>\n<p><a href=\"#item37\">item37:绝不重新定义继承而来的缺省参数值</a></p>\n<p><a href=\"#item38\">item38:通过符合塑模出has-a或者\"根据某物实现出\"</a></p>\n<p><a href=\"#item39\">item39:明智而审慎的使用private继承</a></p>\n<p><a href=\"#item40\">item40:明智而审慎的使用多重继承</a></p>\n<h1 id=\"item26\">item26</h1>\n<p>延后定义变量,防止出现多余的构造与析构的动作.比如:你定义一个控制流,</p>\n<p>但是在控制流之前定义了一个<code>widget</code>,但是只有一个分支使用了它,</p>\n<p>如果没有进入这个分支,那么需要额外承受<code>widget</code>的构造与析构.</p>\n<p>但是循环的时候:</p>\n<pre><code>widget w;\nfor(const auto&amp;i:widgetList){\n    w=i;\n    //...\n}\n</code></pre>\n<p>定义在循环外,会有一个构造,n个复制,一个析构.</p>\n<p>定义在循环内,有n个拷贝构造,n个析构.</p>\n<p>这完全取决于成本了.需要看情况考虑.</p>\n<h1 id=\"item27\">item27</h1>\n<p>尽量少使用cast.四种cast中<code>dynamic_cast</code>是在运行时决定的.这会浪费效率.</p>\n<p>如果必须用cast,尽量自己封装而不是调用者使用cast.</p>\n<p>尽量是c++风格的转换,这样明显而且明确.</p>\n<p><code>const_cast</code> <code>dynamic_cast</code> <code>static_cast</code> <code>reinterpret_cast</code></p>\n<h1 id=\"item28\">item28</h1>\n<p>避免返回可以修改对象内部的东西.比如:引用,指针,迭代器.这样可以增加封装性.</p>\n<p>然而,并不能绝对的做到.</p>\n<h1 id=\"item29\">item29</h1>\n<p>为\"异常安全\"努力,比如对<code>lock</code>的使用,防止死锁.使用<code>RAII</code>的<code>lock_guard</code>可以避免.</p>\n<p>三种异常保证:</p>\n<ul>\n<li>基本承诺 (异常抛出时,内部一致,然而外部调用不确定)</li>\n<li>强烈保证 (要么成功,要么失败返回原状态)</li>\n<li>不抛掷保证 (不会抛出异常)</li>\n</ul>\n<h1 id=\"item30\">item30</h1>\n<p>了解<code>inline</code>,这只是一个对编译器的建议,并不是保证所有加<code>inline</code>修饰的函数都会被内联.</p>\n<p>要自己权衡是否对某个函数进行<code>inline</code>,尽量不要对构造和析构进行<code>inline</code>.</p>\n<p><code>inline</code>会导致代码膨胀,选择要慎重.</p>\n<h1 id=\"item31\">item31</h1>\n<p>讲文件的编译依赖降低.比如前置声明.</p>\n<p>不过有讨论说:google推荐直接使用<code>include</code>,而不是前置声明.</p>\n<p>防止修改一个class name而影响到headfile的声明.</p>\n<p>头文件应该\"完全且仅有声明式\"</p>\n<h3 id=\"-2\">继承与面向对象设计</h3>\n<h1 id=\"item32\">item32</h1>\n<p><code>public</code> 的继承表明 <code>base</code> 的一切都适用于 <code>derived</code>.</p>\n<h1 id=\"item33\">item33</h1>\n<p>避免继承导致的名称问题.比如:</p>\n<pre><code>class base {\npublic:\n    virtual void func() {\n        cout &lt;&lt; \"base func\" &lt;&lt; endl;\n    }\n};\nclass derived : public base {\npublic:\n    using base::func;\n    /*\n    void func()override {\n        base::func();\n    }\n    */\n    void func(int a) {\n        cout &lt;&lt; \"derived \" &lt;&lt; a &lt;&lt; endl;\n    }\n};\n</code></pre>\n<p>如果不是声明<code>using base::func</code>.或者注释里的转交方法,</p>\n<p>那么<code>derived</code>的实例是无法调用<code>func()</code>的.只能调用<code>func(int)</code></p>\n<h1 id=\"item34\">item34</h1>\n<p>了解\"接口实现\"(c++中体现为纯虚函数)和\"继承实现\"(c++体现为虚函数)</p>\n<p>有时候<code>base</code>class会有一个默认的实现.设置为非虚的.</p>\n<p>让每一个继承者都有一份强制的默认的实现.</p>\n<h1 id=\"item35\">item35</h1>\n<p>有时候这样做更好,比如:</p>\n<p><code>base</code>有一个虚函数为:<code>virtual void fly(){ /*...*/ }</code>,\n有一个非虚的函数为:<code>void doFly(){ fly(); }</code></p>\n<p>每个继承类都有不同的 <code>fly</code>动作,</p>\n<p><code>NVI</code>的手法.</p>\n<h1 id=\"item36\">item36</h1>\n<p>不重新定义继承来的非虚函数,这样会遮掩基类的这个函数</p>\n<h1 id=\"item37\">item37</h1>\n<p>不重新定义继承来的有缺省参数的函数,而使用<a href=\"#item35\">#item35</a>的方法.</p>\n<p>缺省参数(默认参数)是静态绑定的,而虚函数确是动态的.</p>\n<h1 id=\"item38\">item38</h1>\n<p>复合,这是一个在实际设计中很难以直接描述的概念.如果非要举个例子:</p>\n<p>货车 <code>has-a</code> 引擎,轮胎...</p>\n<p>货车 <code>is-a</code>(此处语境为具现) 模版车, 可以<code>run()</code></p>\n<h1 id=\"item39\">item39</h1>\n<p><code>private</code>继承的时候,编译器不会讲<code>derived</code>自动转换为<code>base</code>.</p>\n<p>对接口(纯虚函数)的实现会被忽略掉.只有部分实现被继承.意味着是具现而来的.</p>\n<p>一般来说:只有要求<code>对象最小化</code>才适用.</p>\n<h1 id=\"item40\">item40</h1>\n<p>谨慎的使用多重继承. <del>多重继承是c++的特色,不爽不要玩~23333</del></p>\n<p>这是一个很明显的问题,所以各种书籍都是推荐继承多个接口(内部只有纯虚函数).</p>\n<p>不过有时候多重继承非常的适用.</p>","iso8601Date":"2017-10-26T12:11:00+08:00","basename":"effective_cpp_03","prev":"1","next":"20"}