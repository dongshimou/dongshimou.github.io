[{"title":"effective c++ 读书笔记 02","author":"skadi","date":"2017-10-17 23:30","tags":["读书笔记","cpp"],"content":"\r\n\r\n今天又读了一个章节多.`资源管理`和`设计与声明`\r\n\r\n资源管理感觉基本就是要求申请资源和释放资源要成对出现.\r\n举了一些方法来实现这种做法.\r\n我现在使用`impl`的方式来封装资源.\r\n\r\n例如:\r\n```\r\nclass widget{\r\nprivate:\r\n    struct Private;\r\n    Private* impl;\r\n    // .hpp 声明Private指针\r\n}\r\n\r\nstruct widget::Private{\r\n    string name;\r\n    //其他的成员\r\n    // .cpp 实现\r\n}\r\n```\r\n\r\n基本做到了这些.\r\n\r\n而设计与声明,有[item23](#item23)没做到.为啥要使用c的风格,\r\n即使用gobal函数去替换掉member函数.\r\n\r\n还有[item24](#item24)没有做到,因为没考虑到过这个.\r\n\r\n[item25](#item25)是使用impl模式,但是并没有去特别实现一个swap.\r\n好像我暂时还没遇到过需要swap的情况...~~大概是我忘记了.~~\r\n\r\n参数传`const&`做到了,不返回引用,成员变量为private等等这些都做到了.\r\n\r\n### 资源管理\r\n\r\n[item13:以对象管理资源](#item13)\r\n\r\n[item14:在资源管理类中小心copying行为](#item14)\r\n\r\n[item15:在资源管理类中提供对原始资源的访问](#item15)\r\n\r\n[item16:成对使用new和delete是要采取相同的形式](#item16)\r\n\r\n[item17:以独立语句讲newed对象置入智能指针](#item17)\r\n\r\n### 设计与声明\r\n\r\n[item18:让接口容易被正确使用,不易被误用](#item18)\r\n\r\n[item19:设计class犹如设计type](#item19)\r\n\r\n[item20:宁以pass-by-reference-to-const替换pass-by-value](#item20)\r\n\r\n[item21:必须返回对象时,别妄想返回其reference](#item21)\r\n\r\n[item22:讲成员变量声明为private](#item22)\r\n\r\n[item23:宁以non-member,non-friend替换member函数](#item23)\r\n\r\n[item24:若所有参数皆需类型转换,请为此采用non-member函数](#item24)\r\n\r\n[item25:考虑写出一个不抛异常的swap函数](#item25)\r\n\r\n# item13\r\n\r\n使用RAII对象,保证资源的正确获取和释放.c++11的常见是 `unique_ptr` 和`shared_ptr`.\r\n\r\n我还经常这么用:\r\n```\r\nstruct widget::Private{\r\n    window win;\r\n    //...\r\n};\r\n```\r\n然后使用 `&impl->win` 来传这个window参数.\r\n\r\n# item14\r\n\r\n资源管理类要小心复制行为,一般都建议`delete`复制行为,只复制其资源的引用计数.\r\n\r\n不过所管理的资源的复制行为可以决定RAII对象的复制行为\r\n\r\n# item15\r\n\r\n资源管理类要提供对原始资源的访问,因为要去兼容一些API或者需要进行一些特别的\r\n行为\r\n\r\n是否实现一个隐式的转换函数去访问原始资源,这个需要看情况去决定.实现这个转换,\r\n使得使用起来更加方便,但是可能会出现一些安全问题.\r\n\r\n# item16\r\n\r\n`new`和`delete`需要使用同样的方式, 如果是`new[]` 那么需要 `delete[]`\r\n\r\n`new[]`然后`delete`,虽然原始类型不会有问题,但是自定义的class就可能会出问题.\r\n\r\n还有就是尽量不要使用类似的`typedef`:\r\n```\r\ntypedef std::string AddressLines[4];\r\n//...\r\nauto pal=new AddressLines;\r\n\r\ndelete[] pal;\r\n//而不是delete pal\r\n```\r\n\r\n# item17\r\n\r\n使用单独的语句来讲对象置入智能指针.书中举了一个编译器优化的问题.\r\n```\r\nprocessWidget(std::tr1::shared_ptr<Widget>(new Widget),priority());\r\n```\r\n书上说可能由于编译器优化,执行顺序变成了\r\n\r\n* new Widget\r\n* priority()\r\n* tr1::shared_ptr\r\n\r\n然而c++11的`shared_ptr`只能使用`std::make_shared<Widget>()`返回一个`shared_ptr`,所以...这条就不存在问题了.\r\n\r\n# item18\r\n\r\n让接口更容易使用,不易误用.也就是说要求更好的设计class和function.\r\n\r\n\"促进正确使用\",也就是尽量保证设计出来的接口与使用者习惯保持一致,\r\n或者与内置类型保持一致的行为.\r\n\r\n\"防止误用\",也就是说用一些方法去阻止使用者的不良好的调用.书上举了\r\n`month`的例子,使用`month::Jan()`防止调用api的时候的`int`转换问题\r\n如`date(1993,2,10);`不同的地区习惯不一样.设计为\r\n`date(year(1993),month::Feb(),day(10));`这样出问题会有编译器的提示\r\n\r\n# item19\r\n\r\n设计`class`犹如设计`type`.这个可讨论的范围就很大了.\r\n而且这个需要工程经验的积累.并不是一下就能熟练的.\r\n\r\n* 新类型的对象应该如何被创建和销毁\r\n* 对象的初始化和复制应该有什么差别\r\n* 新类型的对象如果按值传递意味着什么\r\n* 什么是新类型的合法值\r\n* 新类型是否需要配合某个继承图系\r\n* 新类型需要什么养的转换\r\n* 什么样的操作符和函数对此类型而言是合理的\r\n* 什么样的函数应该被`delete`\r\n* 谁会使用这个类型的成员\r\n* 什么是新类型的\"未声明接口\"\r\n* 新类型是否需要转换成一个模版\r\n\r\n# item20\r\n\r\n以const引用的方式代替传值.这个非常好理解.\r\n因为传值的话,会生成原始参数的拷贝,并使用这个拷贝.\r\n这会多产生一次这个类拷贝构造和析构.如果是派生类的话,会更多.\r\n而且,这个类的成员如果是庞大的类的话,那么可以想象是要花费多少\r\n额外的消耗.\r\n\r\n还可以防止传递一个基类指针的时候,把派生类的属性切割了.\r\n\r\n所以我们选择传引用,但是为了保证不被修改,所以需要`const`修饰.\r\n\r\n不过内置类型,如`int``double`之类的就不必了.还有stl的迭代器和`functor`\r\n\r\n# item21\r\n\r\n不要返回临时对象(local stack)的引用或者指针,因为这个对象在离开这个作用域的时候已经被销毁了.这是一个未定义行为,因为你的对象已经不见了.也不要返回引用或者指针指向一个(local static)对象而这个对象可能同时有多个.\r\n\r\n# item22\r\n\r\n成员变量为`private`,使用请使用`function`去获取,保持接口的一致性,因为不知道什么时候这个类就改变了,如果直接调用成员变量可能导致各种后续问题.\r\n\r\n# item23\r\n\r\n然而这一条,我并没有做到,感觉 `non-member`function更加的偏向C.\r\n\r\n比较一下这两个函数:\r\n```\r\nwindow* createWindow(window* w,int width,int height);\r\n//non-member\r\nwindow* window::createWindow(int width,int height);\r\n//member\r\n```\r\n我在`Webkit`浏览器内核经常看到类是的`non-member`函数,\r\n貌似是为了导出c的api\r\n\r\n# item24\r\n\r\n如果函数所有的参数都需要类型转换,使用`non-member`的函数,\r\n这个非常好理解,就是为了防止出错.\r\n用面向对象的方式使用C++,需要注意到这一点.\r\n书上举了一个例子:\r\n```\r\nclass Rational{\r\npublic:\r\n    const Rational operator*(const Rational& rhs)const;\r\n    //...\r\n};\r\n\r\nauto r1=Rational(1)*Rational(2);\r\n//正确\r\nauto r2=Rational(1)*2;\r\n//正确\r\nauto r3=2*Rational(1);\r\n//错误\r\n```\r\n\r\nr2的时候做了一个隐式转换,然而r3却并不能.\r\n\r\n这个时候可以声明一个friend的重载:\r\n```\r\nfriend const node operator*(const node&lhs,const node&rhs);\r\n```\r\n然而书上建议不使用friend,而在class外声明一个`non-member`的重载:\r\n```\r\nconst node operator*(const node&lhs,const node&rhs);\r\n```\r\n\r\n# item25\r\n\r\n考虑写一个不抛出异常的`swap`.stl的swap会进行三次复制.如果采用`impl`的\r\n方法则只需要交换其`impl`指针的地址就行了.\r\n\r\n写了一个`member`的swap的时候,也提供一个`non-member`的swap来调用前者,","iso8601Date":"2017-10-17T23:30:00+08:00","basename":"effective_cpp_02","prev":"1","next":"effective_cpp_01"},{"title":"effective c++ 读书笔记 01","author":"skadi","date":"2017-10-15 20:30","tags":["读书笔记","cpp"],"content":"\r\n\r\njd买的书终于到了,`effective c++`,`more effective c++`.\r\n\r\n还有一本`effective mordern c++`只有英文版,不过现在我的水平看原版太吃力.于是把翻译版本打印了来看.应该过几天才到.\r\n\r\n一口气读了`effective c++`12个item(第一章和第二章),不过这些我都做到了.\r\n\r\n\r\n[item1:视c++为一个语言联邦](#item1)\r\n\r\n[item2:用编译器取代预处理](#item2)\r\n\r\n[item3:尽可能使用const](#item3)\r\n\r\n[item4:确定对象被使用前已先被初始化](#item4)\r\n\r\n[item5:了解c++默默编写并调用哪些函数](#item5)\r\n\r\n[item6:若不想使用编译器自动生成的函数,应该明确拒绝](#item6)\r\n\r\n[item7:为多态基类声明virtual析构函数](#item7)\r\n\r\n[item8:别让异常逃离析构函数](#item8)\r\n\r\n[item9:绝不在构造和析构过程中调用virtual函数](#item9)\r\n\r\n[item10:令operator=返回一个reference to *this](#item10)\r\n\r\n[item11:在operator=中处理\"自我赋值\"](#item11)\r\n\r\n[item12:复制对象时勿忘其每一个成分](#item12)\r\n\r\n# item1\r\n\r\n由于c++演变,所以这条基本暂时可以不用在意,引用[`vczh在怎么样才算是精通 C++`的回答](https://www.zhihu.com/question/19794858/answer/18448868)\r\n> * 面向对象（灵活应用virtual继承+shared_ptr可以达到java/C#的效果）\r\n> * 模板（这里分两类，分别为type rich programming和meta programming，区别很大）\r\n> * 函数式编程（如今有了lambda，配合<algorithm>文件，简直无敌了）\r\n> * 过程式\r\n\r\n> 但是难能可贵的是，这几种东西在C++混在一起用也是多么的自然。不过，这需要你花时间去掌控他。那到底有没有必要真的学到这个地步呢，我觉得跟你的领域是有关系的。譬如说我，基本上算是人格分裂的，因为：\r\n> * 当我搞语言设计和编译器的时候，我总是会倾向于创造各种小DSL来给自己用，用的都是模板（想想boost的spirit大概就明白我的意思了，虽然我不用它），尽量让跟我有同样背景的人一眼能看懂我代码的意思。\r\n> * 当我做我那个GUI库（www.gaclib.net）的时候，纯粹是用OO和IoC那一套。\r\n> * 当我写3D渲染程序的时候，我会变成一个为了性能不惜牺牲可读性的人。\r\n\r\n\r\n# item2\r\n\r\n例如\r\n`const double PI=3.14159`\r\n比\r\n`#define PI 3.14159`\r\n要好得多,因为当PI宏因为各种情况出问题的时候,报错信息更加易读.而且不会\r\n导致目标代码出现多个份`3.14159`.\r\n\r\n书上介绍了因为宏替换出现的麻烦情况.\r\n```\r\n#define CALL_WITH_MAX(a,b) func((a)>(b) ? (a):(b) )\r\nint a=5,b=0;\r\nCALL_WITH_MAX(++a,b);\r\nCALL_WITH_MAX(++a,b+10);\r\n```\r\n然而使用inline模版就不会出现这种情况.\r\n\r\n# item3\r\n\r\n很常见,`const`修饰.例如:\r\n```\r\nclass point{\r\n    //... other code\r\nprivate:\r\n    widget* m_widget;    \r\npublic:\r\n    widget* getWidget()const;\r\n    //... other code\r\n}\r\n```\r\n让获取的 `widget*` 不可修改.\r\n\r\n总之,推荐的是 const everywhere .\r\n\r\n# item4\r\n\r\n```\r\nclass node{\r\npublic:\r\n    node(const Item& a,const string& b)\r\n        :m_item(a),m_str(b){\r\n            //...other\r\n        }\r\n    /*\r\n    node(const Item& a,const string& b){\r\n            m_item=a;\r\n            m_str=b;\r\n            //...other\r\n        }\r\n    */\r\nprivate:\r\n    Item m_item;\r\n    string m_str;\r\n}\r\n```\r\n* 未注释的构造函数比注释的构造函数可能性能更好.\r\n* 对内置类型,如 `int` 手动初始化,因为c++不保证初始化它们.\r\n* 面临跨编译单元初始化次序的时候,要使用local-static对象代替non-local-static对象.\r\n\r\n全局变量会被默认初始化为0,local-static对象在调用的时候会保证被初始化.\r\n\r\n# item5\r\n\r\n当你写一个空的class:\r\n```\r\nclass node{\r\n\r\n};\r\n```\r\n* c++11会默认生成`构造`,`拷贝构造`,`拷贝赋值`,`移动构造`,`移动赋值`,`析构`六个函数,当然是在调用的时候.(move,移动相关的函数是c++11之后才有的)\r\n* 编译器生成的析构函数是非虚.\r\n\r\nc++11可以声明为`default`.\r\n\r\n# item6\r\n\r\n比如你设计的一个类不想让它被复制.那么书上的推荐做法是将`拷贝构造`和`拷贝赋值`的函数设置为`private`.\r\n\r\n或者设计一个`unCopy`的基类,并继承.\r\n\r\n然而在c++11,可以将其声明为`delete`.\r\n\r\n```\r\nclass node{\r\npublic:\r\n    node()=default;\r\n    node(const node& other)=delete;\r\n    node& operator=(const node& other)=delete;\r\n}\r\n```\r\n\r\n# item7\r\n\r\n为多态的基类的析构函数设置为 `virtual` ,防止`局部销毁`(基类没有释放).\r\n\r\n如果不是这样的话,设置为 `non-virtual` 非虚.因为虚表会让对象体积变大.\r\n在c++11中,有 `final` 关键字防止被类被派生或者函数被重写.\r\n\r\n```\r\nclass base{\r\n    virtual void show(){\r\n    }\r\n};\r\n\r\nclass AAA final:public base{\r\n\r\n};\r\n//AAA 不可派生\r\nclass BBB:public base{\r\n    void show()override final{\r\n\r\n    }\r\n}\r\n//BBB 可以派生,但是不可以重写 show\r\n```\r\n\r\n\r\n# item8\r\n\r\n这一条讲的是析构函数不要抛出异常.\r\n\r\n在c++11后,析构函数都是默认`noexcept(true)`,遇到异常就crash.\r\n\r\n至于[`noexcept`在Stackoverflow上有相关的讨论](https://stackoverflow.com/questions/10787766/when-should-i-really-use-noexcept)\r\n关于什么时候该使用`noexcept`\r\n\r\n# item9\r\n\r\n在构造函数和析构函数中不要调用虚函数.\r\n因为会将对象视为`base class`类型.而不是`derived class`\r\n\r\n例如:\r\n```\r\nclass base{\r\npublic:\r\n    base(){\r\n        log();\r\n        //不要调用\r\n    }\r\n    virtual void log()const=0;\r\n    //接口\r\n};\r\nclass node:public base{\r\npublic:\r\n    node()=default;\r\n    void log()const override {\r\n        cout<<\"node log\"<<endl;\r\n    }\r\n};\r\n```\r\n这样是没法调用`node`的`log`的.\r\n\r\n# item10\r\n\r\n一个协议,使得可以完成 `a=b=c=10` 这样赋值.\r\n\r\n# item11\r\n\r\n* 实现自我赋值安全\r\n* 推广到其他函数如果操作多个对象,其中有多个是同一个对象,保证行为正确\r\n\r\n# item12\r\n\r\n保证copy的时候会复制所有的成员,特别是子类.\r\n推广到c++11的move的时候也一样.\r\n","iso8601Date":"2017-10-15T20:30:00+08:00","basename":"effective_cpp_01","prev":"effective_cpp_02","next":"17"},{"title":"遇到的一个js的~~玄学~~问题","author":"skadi","date":"2017-10-13 11:08","tags":["JavaScript","玄学","Date","Sort"],"content":"\r\n\r\n整理这个posts的排序的时候遇到了一个~~玄学~~问题....\r\n\r\n`2017-05-23 15:54` 和 `2017-05-23 11:07`\r\n\r\n我的1.md和2.md的时间.\r\n但是莫名其妙的是 `2017-05-23 15:54` 排在 `2017-05-23 11:07` \r\n前面.\r\n\r\n然而我单独写了`test.js`拿来试md的时间的时候.又正常了.\r\n然而在我的网站的build脚本里面却怎么都不对.\r\n\r\nQWQ,找了半天发现是js的compare functor 的问题.\r\n\r\n写多了cpp,以为比较就两个值 `true` or `false`.\r\n\r\n所以就写成了\r\n```\r\nresults.sort((a, b) => {\r\n  return a>b;\r\n});\r\n```\r\n结果发现居然要返回`>0``<0``==0`三种情况.\r\n```\r\nresults.sort((a, b) => {\r\n    let ad = a.date;\r\n    let bd = b.date;\r\n    if (ad > bd)\r\n        return -1;\r\n    else if (ad < bd)\r\n        return 1;\r\n    else\r\n        return 0;\r\n})\r\n//时间倒序排\r\n```\r\n改了之后终于能正确按照时间排序了.","iso8601Date":"2017-10-13T11:08:00+08:00","basename":"17","prev":"effective_cpp_01","next":"16"},{"title":"hello Shanghai","author":"skadi","date":"2017-10-11 23:30","tags":["上海","杂记"],"content":"\r\n\r\n离开成都来到了上海...唉,不知道怎么说.\r\n心情挺复杂的.还有工作到底找什么还没想好.\r\n\r\n明天开始找工作.坐了飞机到现在还是头晕.准备睡觉.\r\n\r\n~~good night~~","iso8601Date":"2017-10-11T23:30:00+08:00","basename":"16","prev":"17","next":"15"},{"title":"动态光晕效果","author":"skadi","date":"2017-09-16 13:10","tags":["qt","halo","光晕效果"],"content":"\r\n\r\n起因是因为看到 SAO游戏里面 button的光晕特效.我也想要~~~\r\n\r\n![](https://user-images.githubusercontent.com/9100799/30509331-e3fd14dc-9ae0-11e7-8da4-38e31424ab7c.jpg)\r\n![](https://user-images.githubusercontent.com/9100799/30509333-e3ff2ace-9ae0-11e7-832d-7f46d1346b40.jpg)\r\n\r\n类似这种呼吸灯的特效.\r\n\r\n摸了半天,只想到qtimer来定时调整alpha channel的值..\r\n\r\n做出来的效果如下:\r\n\r\n![](https://user-images.githubusercontent.com/9100799/30509330-e3fb17fe-9ae0-11e7-9137-b2f95d1d66af.png)\r\n![](https://user-images.githubusercontent.com/9100799/30509332-e3fd8c50-9ae0-11e7-9935-7c5c94fbe32a.png)\r\n\r\n只有外边框效果...然而SAO这里却是整体的widget都有...\r\n\r\n我继续尝试一下能不能用`QGraphicsOpacityEffect`或者`QGraphicsDropShadowEffect`或者其他自带的来画整体的.\r\n\r\n因为我这个方法有一个问题,设置圆角矩形的时候,圆角因为画线的原因.并不能完全填充.设置了反走样也没用.真是个蛋疼的问题.","iso8601Date":"2017-09-16T13:10:00+08:00","basename":"15","prev":"16","next":"14"},{"title":"一个无边框的qt的顶级窗口","author":"skadi","date":"2017-09-15 13:38","tags":["cpp","qt","window"],"content":"\r\n\r\n打算写个类似SAO风格的window,但是qt的顶级的window都有window窗口状态栏.\r\n使用`Qt::FramelessWindowHint`之后,鼠标事件之类的又没了.\r\n\r\n我只是希望有一个顶级窗口来作为容器.所以就自己写了一个.本来是有`QSizeGrip`\r\n可以\r\n\r\n来resize操作的,但是这样就有了一个右下角的瑕疵.所以还是自己重写了.\r\n\r\noverride了这些函数:\r\n```\r\nvoid mousePressEvent(QMouseEvent *event)override;\r\nvoid mouseReleaseEvent(QMouseEvent *event)override;\r\nvoid mouseDoubleClickEvent(QMouseEvent *event)override;\r\nvoid mouseMoveEvent(QMouseEvent *event)override;\r\n```\r\n\r\n写完了一对比,不行啊.我要的圆角呢.这窗口没圆角啊.又不想直接使用windowsAPI.\r\n然后又继续魔改`content`窗口.\r\n```\r\nsetAttribute(Qt::WA_TranslucentBackground);\r\n```\r\n设置顶级窗口透明,里面的`QWidget`再设置圆角`border-radius: 20px;`.\r\n不过遇到一个很迷的事情.`content`\r\n\r\n窗口的child是一个`QWidget`,如果不在这个widget的构造函数里面给他设置background,居然就直接全透了.\r\n\r\n`content`和它的child都透.而且,即使设置了`this->setObjectName(\"window\");`.在app.qss里面写\r\n```\r\nQWidget#window{\r\nbackground:transparent;\r\n}\r\n```\r\n也不顶用.必须在构造函数里写.本来不想这样写的.每次`setStyleSheet`都很慢.\r\n\r\no(︶︿︶)o 唉\r\n\r\n```\r\nexplicit content(QWidget* child=nullptr)noexcept;\r\n\r\n//如果要给一个login窗口\r\n//创建一个顶级窗口的容器的话.\r\n\r\nclass login{\r\n    content* ct;\r\n    //other code\r\n    login(){\r\n        ct=new content{this};\r\n        this->setObjectName(\"login\");\r\n        this->setStyleSheet(\"QWidget#login{\"\r\n                            \"background:transparent;\"\r\n                            \"}\"\r\n        );\r\n    }\r\n}\r\n\r\n//这个窗口就没有了状态栏\r\n//再给它设置`border-radius: 20px;`\r\n//那么它就有了圆角\r\n```\r\n\r\n![window](https://user-images.githubusercontent.com/9100799/30468681-2af80828-9a1f-11e7-8928-386397cd2a06.png)\r\n\r\n如图的qss如下\r\n\r\n```\r\nlogin{\r\n    background:#057FBA;\r\n    border-radius: 20px;\r\n    border: 5px solid #837F83;\r\n}\r\n```\r\n\r\n相关源码在这里\r\n\r\n[content.cpp](https://github.com/dongshimou/pp/blob/master/src/content.cpp)\r\n[content.h](https://github.com/dongshimou/pp/blob/master/src/content.h)\r\n\r\n[window.cpp](https://github.com/dongshimou/pp/blob/master/src/window.cpp)\r\n[window.h](https://github.com/dongshimou/pp/blob/master/src/window.h)","iso8601Date":"2017-09-15T13:38:00+08:00","basename":"14","prev":"15","next":"13"},{"title":"qss的一个小问题","author":"skadi","date":"2017-09-14 14:28","tags":["cpp","qt","qss"],"content":"\r\n\r\n好久没上线了,自从离职后天天赋闲在家.打游戏,写代码.感觉昏天黑地的.\r\n自写的游戏引擎感觉还是很搓.用了`glew`和`glfw`.然后又开了一个叫`pp`的项目.\r\n打算写个类是`shadow河蟹`的东西.然后又遇上<<刀剑神域:失落之歌>>上映了.又中了\r\nSAO的毒,开始想把这个写个相关的UI.很不幸,今天遇到了`qt`的一个神奇的问题.\r\n\r\n在qss中这么写\r\n```\r\nQPushButton#login_in:pressed{\r\n    border-image:url(./icon/icon/ok_normal.png);\r\n}\r\nQPushButton#login_in:hover{\r\n    border-image:url(./icon/icon/ok_hover.png);\r\n}\r\n```\r\n\r\n会遇到一个玄学问题,就是只会出现后面的`hover`效果.`pressed`效果被吞了...\r\n\r\n然而只需要在qss文件中将 `:hover`写在`:pressed`之前,两个效果就有了.这算是\r\nbug吧~~\r\n","iso8601Date":"2017-09-14T14:28:00+08:00","basename":"13","prev":"14","next":"12"},{"title":"竟然有这种操作","author":"skadi","date":"2017-07-22 08:30","tags":["c++","函数指针","这种操作"],"content":"\r\n\r\n写这个起因是因为在写qt的时候,有个界面上同一个位置有不同\r\n`Widget`,但是槽都是一样的,而且都是同一个类派生出来的\r\n\r\n然后我写了一个模板去`InitRightLayout`,在接受信号的我\r\n用一个lambda去包裹了一下这个槽,然后被说多次一举.\r\n\r\n举个例子:\r\n\r\n```\r\n//widget a 有一个 onTimeOut\r\n//widget b 继承于a,重写了 onTimeOut\r\n//在模板中\r\ntemplate<class T>\r\nvoid InitRightLayout(T* cap){\r\n    //...\r\n    connect(m_timer,&QTimer::timeout,\r\n    this,[=](){\r\n        onTimeOut();\r\n    });\r\n    //...\r\n}\r\n```\r\n告诉我可以直接写成 `connect(m_timer,&QTimer::timeout,this,&a::onTimeOut)`. \r\n\r\nQWQ,还有这种操作,不怕全调用了a的`onTimeOut`么?然后我测试了一下\r\n\r\n```\r\nclass AAA :public QWidget {\r\npublic:\r\n    AAA(QWidget*parent = nullptr) :QWidget(parent) { init(); };\r\n    virtual void onTest() { qDebug() << \"AAA\"; }\r\n    void init() {\r\n        auto t = new QTimer{ this };\r\n        connect(t, &QTimer::timeout, this, &AAA::onTest);\r\n        t->start(1000);\r\n    }\r\n};\r\nclass BBB :public AAA {\r\npublic:\r\n    BBB(QWidget*parent = nullptr) :AAA(parent) { };\r\n    virtual void onTest()override { qDebug() << \"BBB\"; }\r\n};\r\n```\r\n\r\n真的是输出`BBB`,`AAA::onTest`只是一个虚地址啊,学习了.最后写了一个demo来学习一下.\r\n\r\n```\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nstruct AAA {\r\n    virtual void func() { cout << \"AAA\" << endl; }\r\n};\r\n\r\nstruct BBB : AAA {\r\n    virtual void func() override { cout << \"BBB\" << endl; }\r\n};\r\n\r\nvoid run(AAA *s, void (AAA::*const f)(void)) {\r\n    (s->*f)();\r\n    return;\r\n}\r\nint main() {\r\n    AAA a;\r\n    BBB b;\r\n    constexpr const auto f = &AAA::func;\r\n    run(&a, f);\r\n    run(&b, f);\r\n    cin.get();\r\n    return 0;\r\n}\r\n```","iso8601Date":"2017-07-22T08:30:00+08:00","basename":"12","prev":"13","next":"11"},{"title":"许久没有写了,我需要发泄","author":"skadi","date":"2017-07-12 19:00","tags":["any"],"content":"\r\n\r\n最近好累,我很不想喷的,但是!不给安空调什么鬼啊.\r\n顶着30+的高温写代码???\r\n\r\n还有什么必须答\"好\"?\"不能装作听不到\"!!!\r\nEXM??? 我感觉我进了一个假的互联网公司.\r\n\r\n最近不仅热气爆棚,怨气怒气也爆棚了.\r\n","iso8601Date":"2017-07-12T19:00:00+08:00","basename":"11","prev":"12","next":"10"},{"title":"我是个撒币","author":"skadi","date":"2017-06-05 17:00","tags":["cpp"],"content":"\r\n\r\n我真是个撒币,可以`nth_element`,可以二分的,我弄了个sort.\r\nlinklist写出段错误,一方面是因为太久没写,一方面是因为不细心,\r\n还有就是webide调试不便.\r\n\r\nlambda的递归居然忘了`[&]`,还有各种撒比的犯错,一个简单的东西\r\n搞得自己表现得像个小丑.更撒比的是开头把话说满了!我真是个辣鸡.\r\n\r\n###谨记这次撒币行为","iso8601Date":"2017-06-05T17:00:00+08:00","basename":"10","prev":"11","next":"9"},{"title":"javascript的坑","author":"skadi","date":"2017-05-31 09:01","tags":["javascript","for"],"content":"\r\n\r\n在给我的`post`添加`next`和`prev`的时候\r\n写了一句:\r\n\r\n```\r\n...\r\narr[i].next=arr[i+1].basename\r\n...\r\narr[i].prev=arr[i-1].basename\r\n```\r\n\r\n一个`arr[i+1]`竟然是`undefine`.\r\n明明我判断过 `i==arr.length-1`\r\n\r\n赶紧把`i`打印出来,结果发现没错啊`i=0`\r\n而且`arr.length`是肯定大于1的啊.\r\n\r\n赶紧把`i`和`i+1`打印出来...结果\r\n\r\n`i` = `0` 然而发现\r\n`i+1` = `01`\r\n\r\nWTF??? `for(let i in arr)`的\r\n`i`的类型是`string`??exm???\r\n心里cnm奔腾...","iso8601Date":"2017-05-31T09:01:00+08:00","basename":"9","prev":"10","next":"8"},{"title":"markdown to html 的小问题2","author":"skadi","date":"2017-05-27 09:11","tags":["markdown","html","vue","html history"],"content":"\r\n\r\n在dev的时候发现tohtml后的html依然存在md锚点不正确的情况\r\n\r\n瞄了一眼url,瞬间明白了...vue使用了#,所以这锚点还怎么搞嘛\r\n\r\n只能去改 vue的router 配置了.资料:\r\n[vue router(html5 history)](https://router.vuejs.org/zh-cn/essentials/history-mode.html)\r\n介绍.\r\n\r\n改了router,但是这个东西...需要后端配置,只能试试github.io能不能支持了.\r\n\r\n~~话说我的404页面还没写...~~","iso8601Date":"2017-05-27T09:11:00+08:00","basename":"8","prev":"9","next":"7"},{"title":"markdown to html 的小问题","author":"skadi","date":"2017-05-27 09:00","tags":["markdown","html"],"content":"\r\n\r\n我的这个io站用了`var markdown = require('markdown').markdown;`\r\n的`markdown.toHTML`方法,然而发现导出的html其实是有问题的.\r\n\r\n > 比如这种引用块都没有加上`blockquote`\r\n\r\n还有就是类似 `[update](#update1)我是更新链接` 这种在tohtml\r\n后并没有生成正确的href.\r\n\r\n至于其他的bug什么的,暂时还没有发现.\r\n\r\n于是我就换了`showdown`,测试了一下发现正常了.果断换用.","iso8601Date":"2017-05-27T09:00:00+08:00","basename":"7","prev":"8","next":"6"},{"title":"记一次煞笔行为","author":"skadi","date":"2017-05-26 17:00","tags":["qt","qtchart","f**k"],"content":"\r\n\r\n\r\n\r\n--- \r\n[2017/05/26 20:00](#update1)更新\r\n\r\n---\r\n\r\n### fuck qtchart!!!\r\n\r\n写得`radarChart`继承于`QChartView`\r\n\r\n然后f**k的事情来了.各种设置背景色失败.\r\n\r\n```\r\nm_viewer->setBackgroundBrush(Qt::red);\r\n```\r\n\r\n结果就是一个红色边框\r\n\r\n```\r\nm_viewer->chart()->setBackgroundBrush(Qt::red);\r\n```\r\n\r\n结果就是啥都没有\r\n\r\n最后,实在没法,新建了一个demo,直接挨个套.\r\nf**k的事情出现了,设置背景成功了...\r\n一模一样的代码...\r\n\r\n最后,我在自己定义的`randarChart`内部调用了一次\r\n```\r\nchart()->setBackgroundBrush(Qt::red)\r\n```\r\n也行? WTF???\r\n\r\n最后我发现我在内部调用的时候是写在`setChart(xxx)`之后的.\r\n\r\n而外面调用时写在`setChart(xxx)`之前的.\r\n\r\n话说一个`QChartView`在没有`setChart()`之前调用`Chart()`来获取其`chart`难道不应该直接`assert(chart!=nullptr)`么?\r\n\r\n虽然我是自己傻逼造成的这个问题,qt难道不是加这么个一条来进行处理么?\r\n\r\n### update1\r\n\r\n看了源码,结果发现在没有`setChart()`的时候默认是`new`的一个,在`setChart()`的时候,原来的会`memmove`,但是居然要求手动`release`!! WTF???\r\n > To avoid memory leaks users need to make sure the previous chart is deleted.\r\n\r\nWTF???\r\n\r\n[setChart](https://doc.qt.io/qt-5/qchartview.html#setChart)的文档,简直有点无法理解啊.","iso8601Date":"2017-05-26T17:00:00+08:00","basename":"6","prev":"7","next":"5"},{"title":"辣鸡电信","author":"skadi","date":"2017-05-25 20:00","tags":["proxy","npm","git","gfw"],"content":"\r\n\r\n### git和npm开proxy\r\n\r\n本来打算clone一个项目的,没想到家里电信真是卡出翔了.\r\n没办法只好给git设置proxy了.\r\n\r\n开代理\r\n\r\n```\r\ngit config --global http.proxy socks5://127.0.0.1:1080\r\ngit config --global https.proxy socks5://127.0.0.1:1080\r\n```\r\n\r\n关代理\r\n\r\n```\r\ngit config --global --unset http.proxy\r\ngit config --global --unset https.proxy\r\n```\r\n\r\n结果发现我的`npm i`又奇慢无比...\r\n\r\n```\r\nnpm config set proxy http://127.0.0.1:1080 --global\r\nnpm config set https-proxy http://127.0.0.1:1080 --global\r\n```\r\n\r\n```\r\nnpm config delete proxy\r\n```\r\n~~不想使用taobao的源,就这样吧~~","iso8601Date":"2017-05-25T20:00:00+08:00","basename":"5","prev":"6","next":"4"},{"title":"写qt写qt写qt","author":"skadi","date":"2017-05-24 19:00","tags":["日常","qt","radar","cpp"],"content":"\r\n\r\n突然又有了雷达图的需求...这一天三改真是够了!!!\r\nqt没有现成的雷达图,chartdir有,但是并不能在手机上弄.\r\n现在又非要考虑手机平台,只好用qt搞一个了.\r\n其实也说不上搞一个,有一个`QPolarChart`,再封装一下就行了.\r\n主要是需求也不确定,每次都是\"诶!,我觉得这样不错,改一下.\".\r\n###WTF!!!","iso8601Date":"2017-05-24T19:00:00+08:00","basename":"4","prev":"5","next":"3"},{"title":"继续修改主页","author":"skadi","date":"2017-05-24 08:00","tags":["日常","改主页","todo"],"content":"\r\n\r\n把`post`的位置放在static.\r\n然后把`resume.md`的位置腾出来了.\r\n等到周末去把简历放上去,然后还要发给逸国的dalao.\r\n\r\n### 本周 todo\r\n\r\n* 周末写简历\r\n* resume的页面\r\n* c++1z的跟进\r\n\r\n哦,想起来dota2本子的任务还没搞.\r\n算了,晚上好像没时间打了,周末再说.","iso8601Date":"2017-05-24T08:00:00+08:00","basename":"3","prev":"4","next":"2"},{"title":"posts测试","author":"skadi","date":"2017-05-23 15:54","tags":["日常","无聊"],"content":"\r\n\r\n文章首页显示最新的三个\r\nflex布局话说也用不上,反正都是竖着的.","iso8601Date":"2017-05-23T15:54:00+08:00","basename":"2","prev":"3","next":"1"},{"title":"又是一个无聊的日子","author":"skadi","date":"2017-05-23 11:07","tags":["日常","无聊"],"content":"\r\n\r\n## 不知道写啥\r\n\r\n反正就是有点无聊.\r\n\r\n顺便弄了 `markdown to json`\r\n\r\n话说还要把简历也放上去,个人的web也还没弄好.Orz\r\n\r\n每天12个小时的上班也是够了! 下班回去就只想躺下.\r\n\r\n就算强打着精神打打游戏,写写代码.也是困得不行.\r\n\r\n哎. ","iso8601Date":"2017-05-23T11:07:00+08:00","basename":"1","prev":"2","next":"effective_cpp_02"}]