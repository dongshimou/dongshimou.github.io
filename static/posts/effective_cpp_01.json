{"title":"effective c++ 读书笔记 01","author":"skadi","date":"2017-10-15 20:30","tags":["读书笔记","cpp"],"content":"<p>jd买的书终于到了,<code>effective c++</code>,<code>more effective c++</code>.</p>\n<p>还有一本<code>effective mordern c++</code>只有英文版,不过现在我的水平看原版太吃力.于是把翻译版本打印了来看.应该过几天才到.</p>\n<p>一口气读了<code>effective c++</code>12个item(第一章和第二章),不过这些我都做到了.</p>\n<p><a href=\"#item1\">item1:视c++为一个语言联邦</a></p>\n<p><a href=\"#item2\">item2:用编译器取代预处理</a></p>\n<p><a href=\"#item3\">item3:尽可能使用const</a></p>\n<p><a href=\"#item4\">item4:确定对象被使用前已先被初始化</a></p>\n<p><a href=\"#item5\">item5:了解c++默默编写并调用哪些函数</a></p>\n<p><a href=\"#item6\">item6:若不想使用编译器自动生成的函数,应该明确拒绝</a></p>\n<p><a href=\"#item7\">item7:为多态基类声明virtual析构函数</a></p>\n<p><a href=\"#item8\">item8:别让异常逃离析构函数</a></p>\n<p><a href=\"#item9\">item9:绝不在构造和析构过程中调用virtual函数</a></p>\n<p><a href=\"#item10\">item10:令operator=返回一个reference to *this</a></p>\n<p><a href=\"#item11\">item11:在operator=中处理\"自我赋值\"</a></p>\n<p><a href=\"#item12\">item12:复制对象时勿忘其每一个成分</a></p>\n<h1 id=\"item1\">item1</h1>\n<p>由于c++演变,所以这条基本暂时可以不用在意,引用<a href=\"https://www.zhihu.com/question/19794858/answer/18448868\"><code>vczh在怎么样才算是精通 C++</code>的回答</a></p>\n<blockquote>\n  <ul>\n  <li>面向对象（灵活应用virtual继承+shared_ptr可以达到java/C#的效果）</li>\n  <li>模板（这里分两类，分别为type rich programming和meta programming，区别很大）</li>\n  <li>函数式编程（如今有了lambda，配合<algorithm>文件，简直无敌了）</li>\n  <li>过程式</li>\n  </ul>\n  <p>但是难能可贵的是，这几种东西在C++混在一起用也是多么的自然。不过，这需要你花时间去掌控他。那到底有没有必要真的学到这个地步呢，我觉得跟你的领域是有关系的。譬如说我，基本上算是人格分裂的，因为：</p>\n  <ul>\n  <li>当我搞语言设计和编译器的时候，我总是会倾向于创造各种小DSL来给自己用，用的都是模板（想想boost的spirit大概就明白我的意思了，虽然我不用它），尽量让跟我有同样背景的人一眼能看懂我代码的意思。</li>\n  <li>当我做我那个GUI库（www.gaclib.net）的时候，纯粹是用OO和IoC那一套。</li>\n  <li>当我写3D渲染程序的时候，我会变成一个为了性能不惜牺牲可读性的人。</li>\n  </ul>\n</blockquote>\n<h1 id=\"item2\">item2</h1>\n<p>例如\n<code>const double PI=3.14159</code>\n比\n<code>#define PI 3.14159</code>\n要好得多,因为当PI宏因为各种情况出问题的时候,报错信息更加易读.而且不会\n导致目标代码出现多个份<code>3.14159</code>.</p>\n<p>书上介绍了因为宏替换出现的麻烦情况.</p>\n<pre><code>#define CALL_WITH_MAX(a,b) func((a)&gt;(b) ? (a):(b) )\nint a=5,b=0;\nCALL_WITH_MAX(++a,b);\nCALL_WITH_MAX(++a,b+10);\n</code></pre>\n<p>然而使用inline模版就不会出现这种情况.</p>\n<h1 id=\"item3\">item3</h1>\n<p>很常见,<code>const</code>修饰.例如:</p>\n<pre><code>class point{\n    //... other code\nprivate:\n    widget* m_widget;    \npublic:\n    widget* getWidget()const;\n    //... other code\n}\n</code></pre>\n<p>让获取的 <code>widget*</code> 不可修改.</p>\n<p>总之,推荐的是 const everywhere .</p>\n<h1 id=\"item4\">item4</h1>\n<pre><code>class node{\npublic:\n    node(const Item&amp; a,const string&amp; b)\n        :m_item(a),m_str(b){\n            //...other\n        }\n    /*\n    node(const Item&amp; a,const string&amp; b){\n            m_item=a;\n            m_str=b;\n            //...other\n        }\n    */\nprivate:\n    Item m_item;\n    string m_str;\n}\n</code></pre>\n<ul>\n<li>未注释的构造函数比注释的构造函数可能性能更好.</li>\n<li>对内置类型,如 <code>int</code> 手动初始化,因为c++不保证初始化它们.</li>\n<li>面临跨编译单元初始化次序的时候,要使用local-static对象代替non-local-static对象.</li>\n</ul>\n<p>全局变量会被默认初始化为0,local-static对象在调用的时候会保证被初始化.</p>\n<h1 id=\"item5\">item5</h1>\n<p>当你写一个空的class:</p>\n<pre><code>class node{\n\n};\n</code></pre>\n<ul>\n<li>c++11会默认生成<code>构造</code>,<code>拷贝构造</code>,<code>拷贝赋值</code>,<code>移动构造</code>,<code>移动赋值</code>,<code>析构</code>六个函数,当然是在调用的时候.(move,移动相关的函数是c++11之后才有的)</li>\n<li>编译器生成的析构函数是非虚.</li>\n</ul>\n<p>c++11可以声明为<code>default</code>.</p>\n<h1 id=\"item6\">item6</h1>\n<p>比如你设计的一个类不想让它被复制.那么书上的推荐做法是将<code>拷贝构造</code>和<code>拷贝赋值</code>的函数设置为<code>private</code>.</p>\n<p>或者设计一个<code>unCopy</code>的基类,并继承.</p>\n<p>然而在c++11,可以将其声明为<code>delete</code>.</p>\n<pre><code>class node{\npublic:\n    node()=default;\n    node(const node&amp; other)=delete;\n    node&amp; operator=(const node&amp; other)=delete;\n}\n</code></pre>\n<h1 id=\"item7\">item7</h1>\n<p>为多态的基类的析构函数设置为 <code>virtual</code> ,防止<code>局部销毁</code>(基类没有释放).</p>\n<p>如果不是这样的话,设置为 <code>non-virtual</code> 非虚.因为虚表会让对象体积变大.\n在c++11中,有 <code>final</code> 关键字防止被类被派生或者函数被重写.</p>\n<pre><code>class base{\n    virtual void show(){\n    }\n};\n\nclass AAA final:public base{\n\n};\n//AAA 不可派生\nclass BBB:public base{\n    void show()override final{\n\n    }\n}\n//BBB 可以派生,但是不可以重写 show\n</code></pre>\n<h1 id=\"item8\">item8</h1>\n<p>这一条讲的是析构函数不要抛出异常.</p>\n<p>在c++11后,析构函数都是默认<code>noexcept(true)</code>,遇到异常就crash.</p>\n<p>至于<a href=\"https://stackoverflow.com/questions/10787766/when-should-i-really-use-noexcept\"><code>noexcept</code>在Stackoverflow上有相关的讨论</a>\n关于什么时候该使用<code>noexcept</code></p>\n<h1 id=\"item9\">item9</h1>\n<p>在构造函数和析构函数中不要调用虚函数.\n因为会将对象视为<code>base class</code>类型.而不是<code>derived class</code></p>\n<p>例如:</p>\n<pre><code>class base{\npublic:\n    base(){\n        log();\n        //不要调用\n    }\n    virtual void log()const=0;\n    //接口\n};\nclass node:public base{\npublic:\n    node()=default;\n    void log()const override {\n        cout&lt;&lt;\"node log\"&lt;&lt;endl;\n    }\n};\n</code></pre>\n<p>这样是没法调用<code>node</code>的<code>log</code>的.</p>\n<h1 id=\"item10\">item10</h1>\n<p>一个协议,使得可以完成 <code>a=b=c=10</code> 这样赋值.</p>\n<h1 id=\"item11\">item11</h1>\n<ul>\n<li>实现自我赋值安全</li>\n<li>推广到其他函数如果操作多个对象,其中有多个是同一个对象,保证行为正确</li>\n</ul>\n<h1 id=\"item12\">item12</h1>\n<p>保证copy的时候会复制所有的成员,特别是子类.\n推广到c++11的move的时候也一样.</p>","iso8601Date":"2017-10-15T20:30:00+08:00","basename":"effective_cpp_01","prev":"effective_cpp_02","next":"17"}